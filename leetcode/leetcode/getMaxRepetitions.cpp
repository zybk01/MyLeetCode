#include "stdafx.h"
#include<string>
#include<algorithm>
#include<unordered_map>
#include<iostream>
using namespace std;


class Solution {
public:
	int getMaxRepetitions(string s1, int n1, string s2, int n2) {
		int len1 = s1.length();
		int len2 = s2.length();
		int ptr = 0;
		int i = 0;
		int mark1 = 0;
		int knotadd = 0;
		for (;;)
		{
			if (i >= len1*n1)
			{
				return ptr/len2/n2;
			}
			if (i > (len1*(len2 + 1))) {
				//cout << i << endl;
			}
			if (s1[(i%len1)] == s2[(ptr%len2)]) {
				if (ptr==0)
				{
					mark1 = i;
				}
				else if (ptr%len2==0&&i%len1==mark1)
				{
					//return (n1*(ptr / len2)*len1/ ((i - mark1))/n2 );

					knotadd = ((n1*len1 - mark1)/ (i - mark1)-1)*(i-mark1);
					mark1 = (n1*len1-mark1) / (i-mark1) *(ptr / len2);
					break;
					
				}
				
				ptr++;
			}
			i++;
		}
		ptr = 0;
		i = i +knotadd;

		for (;;)
		{
			if (i >= len1*n1)
			{
				return (mark1+ptr / len2 )/ n2;
			}
			if (s1.at(i%len1) == s2.at(ptr%len2)) {
				ptr++;
			}
			i++;
		}

		return 1;

	}
};




//class Solution {
//public:
//	int getMaxRepetitions(string s1, int n1, string s2, int n2) {
//		if (n1 == 0) {
//			return 0;
//		}
//		int s1cnt = 0, index = 0, s2cnt = 0;
//		// recall 是我们用来找循环节的变量，它是一个哈希映射
//		// 我们如何找循环节？假设我们遍历了 s1cnt 个 s1，此时匹配到了第 s2cnt 个 s2 中的第 index 个字符
//		// 如果我们之前遍历了 s1cnt' 个 s1 时，匹配到的是第 s2cnt' 个 s2 中同样的第 index 个字符，那么就有循环节了
//		// 我们用 (s1cnt', s2cnt', index) 和 (s1cnt, s2cnt, index) 表示两次包含相同 index 的匹配结果
//		// 那么哈希映射中的键就是 index，值就是 (s1cnt', s2cnt') 这个二元组
//		// 循环节就是；
//		//    - 前 s1cnt' 个 s1 包含了 s2cnt' 个 s2
//		//    - 以后的每 (s1cnt - s1cnt') 个 s1 包含了 (s2cnt - s2cnt') 个 s2
//		// 那么还会剩下 (n1 - s1cnt') % (s1cnt - s1cnt') 个 s1, 我们对这些与 s2 进行暴力匹配
//		// 注意 s2 要从第 index 个字符开始匹配
//		unordered_map<int, pair<int, int>> recall;
//		pair<int, int> pre_loop, in_loop;
//		while (true) {
//			// 我们多遍历一个 s1，看看能不能找到循环节
//			++s1cnt;
//			for (char ch : s1) {
//				if (ch == s2[index]) {
//					index += 1;
//					if (index == s2.size()) {
//						++s2cnt;
//						index = 0;
//					}
//				}
//			}
//			// 还没有找到循环节，所有的 s1 就用完了
//			if (s1cnt == n1) {
//				return s2cnt / n2;
//			}
//			// 出现了之前的 index，表示找到了循环节
//			if (recall.count(index)) {
//				auto[s1cnt_prime, s2cnt_prime] = recall[index];
//				// 前 s1cnt' 个 s1 包含了 s2cnt' 个 s2
//				pre_loop = { s1cnt_prime, s2cnt_prime };
//				// 以后的每 (s1cnt - s1cnt') 个 s1 包含了 (s2cnt - s2cnt') 个 s2
//				in_loop = { s1cnt - s1cnt_prime, s2cnt - s2cnt_prime };
//				break;
//			}
//			else {
//				recall[index] = { s1cnt, s2cnt };
//			}
//		}
//		// ans 存储的是 S1 包含的 s2 的数量，考虑的之前的 pre_loop 和 in_loop
//		int ans = pre_loop.second + (n1 - pre_loop.first) / in_loop.first * in_loop.second;
//		// S1 的末尾还剩下一些 s1，我们暴力进行匹配
//		int rest = (n1 - pre_loop.first) % in_loop.first;
//		for (int i = 0; i < rest; ++i) {
//			for (char ch : s1) {
//				if (ch == s2[index]) {
//					++index;
//					if (index == s2.size()) {
//						++ans;
//						index = 0;
//					}
//				}
//			}
//		}
//		// S1 包含 ans 个 s2，那么就包含 ans / n2 个 S2
//		return ans / n2;
//	}
//};
//
